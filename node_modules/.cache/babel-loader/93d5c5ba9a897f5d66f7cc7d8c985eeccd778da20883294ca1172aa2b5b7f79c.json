{"ast":null,"code":"import process from 'node:process';\nconst asyncCallbacks = new Set();\nconst callbacks = new Set();\nlet isCalled = false;\nlet isRegistered = false;\nasync function exit(shouldManuallyExit, isSynchronous, signal) {\n  if (isCalled) {\n    return;\n  }\n  isCalled = true;\n  if (asyncCallbacks.size > 0 && isSynchronous) {\n    console.error(['SYNCHRONOUS TERMINATION NOTICE:', 'When explicitly exiting the process via process.exit or via a parent process,', 'asynchronous tasks in your exitHooks will not run. Either remove these tasks,', 'use gracefulExit() instead of process.exit(), or ensure your parent process', 'sends a SIGINT to the process running this code.'].join(' '));\n  }\n  const exitCode = 128 + signal;\n  const done = (force = false) => {\n    if (force === true || shouldManuallyExit === true) {\n      process.exit(exitCode); // eslint-disable-line unicorn/no-process-exit\n    }\n  };\n  for (const callback of callbacks) {\n    callback(exitCode);\n  }\n  if (isSynchronous) {\n    done();\n    return;\n  }\n  const promises = [];\n  let forceAfter = 0;\n  for (const [callback, wait] of asyncCallbacks) {\n    forceAfter = Math.max(forceAfter, wait);\n    promises.push(Promise.resolve(callback(exitCode)));\n  }\n\n  // Force exit if we exceeded our wait value\n  const asyncTimer = setTimeout(() => {\n    done(true);\n  }, forceAfter);\n  await Promise.all(promises);\n  clearTimeout(asyncTimer);\n  done();\n}\nfunction addHook(options) {\n  const {\n    onExit,\n    wait,\n    isSynchronous\n  } = options;\n  const asyncCallbackConfig = [onExit, wait];\n  if (isSynchronous) {\n    callbacks.add(onExit);\n  } else {\n    asyncCallbacks.add(asyncCallbackConfig);\n  }\n  if (!isRegistered) {\n    isRegistered = true;\n\n    // Exit cases that support asynchronous handling\n    process.once('beforeExit', exit.bind(undefined, true, false, -128));\n    process.once('SIGINT', exit.bind(undefined, true, false, 2));\n    process.once('SIGTERM', exit.bind(undefined, true, false, 15));\n\n    // Explicit exit events. Calling will force an immediate exit and run all\n    // synchronous hooks. Explicit exits must not extend the node process\n    // artificially. Will log errors if asynchronous calls exist.\n    process.once('exit', exit.bind(undefined, false, true, 0));\n\n    // PM2 Cluster shutdown message. Caught to support async handlers with pm2,\n    // needed because explicitly calling process.exit() doesn't trigger the\n    // beforeExit event, and the exit event cannot support async handlers,\n    // since the event loop is never called after it.\n    process.on('message', message => {\n      if (message === 'shutdown') {\n        exit(true, true, -128);\n      }\n    });\n  }\n  return () => {\n    if (isSynchronous) {\n      callbacks.delete(onExit);\n    } else {\n      asyncCallbacks.delete(asyncCallbackConfig);\n    }\n  };\n}\nexport default function exitHook(onExit) {\n  if (typeof onExit !== 'function') {\n    throw new TypeError('onExit must be a function');\n  }\n  return addHook({\n    onExit,\n    isSynchronous: true\n  });\n}\nexport function asyncExitHook(onExit, options = {}) {\n  if (typeof onExit !== 'function') {\n    throw new TypeError('onExit must be a function');\n  }\n  if (!(typeof options.wait === 'number' && options.wait > 0)) {\n    throw new TypeError('wait must be set to a positive numeric value');\n  }\n  return addHook({\n    onExit,\n    wait: options.wait,\n    isSynchronous: false\n  });\n}\nexport function gracefulExit(signal = 0) {\n  exit(true, false, -128 + signal);\n}","map":{"version":3,"names":["process","asyncCallbacks","Set","callbacks","isCalled","isRegistered","exit","shouldManuallyExit","isSynchronous","signal","size","console","error","join","exitCode","done","force","callback","promises","forceAfter","wait","Math","max","push","Promise","resolve","asyncTimer","setTimeout","all","clearTimeout","addHook","options","onExit","asyncCallbackConfig","add","once","bind","undefined","on","message","delete","exitHook","TypeError","asyncExitHook","gracefulExit"],"sources":["/Users/nicholasnewbauer/dominant-color-app/node_modules/exit-hook/index.js"],"sourcesContent":["import process from 'node:process';\n\nconst asyncCallbacks = new Set();\nconst callbacks = new Set();\n\nlet isCalled = false;\nlet isRegistered = false;\n\nasync function exit(shouldManuallyExit, isSynchronous, signal) {\n\tif (isCalled) {\n\t\treturn;\n\t}\n\n\tisCalled = true;\n\n\tif (asyncCallbacks.size > 0 && isSynchronous) {\n\t\tconsole.error([\n\t\t\t'SYNCHRONOUS TERMINATION NOTICE:',\n\t\t\t'When explicitly exiting the process via process.exit or via a parent process,',\n\t\t\t'asynchronous tasks in your exitHooks will not run. Either remove these tasks,',\n\t\t\t'use gracefulExit() instead of process.exit(), or ensure your parent process',\n\t\t\t'sends a SIGINT to the process running this code.',\n\t\t].join(' '));\n\t}\n\n\tconst exitCode = 128 + signal;\n\n\tconst done = (force = false) => {\n\t\tif (force === true || shouldManuallyExit === true) {\n\t\t\tprocess.exit(exitCode); // eslint-disable-line unicorn/no-process-exit\n\t\t}\n\t};\n\n\tfor (const callback of callbacks) {\n\t\tcallback(exitCode);\n\t}\n\n\tif (isSynchronous) {\n\t\tdone();\n\t\treturn;\n\t}\n\n\tconst promises = [];\n\tlet forceAfter = 0;\n\tfor (const [callback, wait] of asyncCallbacks) {\n\t\tforceAfter = Math.max(forceAfter, wait);\n\t\tpromises.push(Promise.resolve(callback(exitCode)));\n\t}\n\n\t// Force exit if we exceeded our wait value\n\tconst asyncTimer = setTimeout(() => {\n\t\tdone(true);\n\t}, forceAfter);\n\n\tawait Promise.all(promises);\n\tclearTimeout(asyncTimer);\n\tdone();\n}\n\nfunction addHook(options) {\n\tconst {onExit, wait, isSynchronous} = options;\n\tconst asyncCallbackConfig = [onExit, wait];\n\n\tif (isSynchronous) {\n\t\tcallbacks.add(onExit);\n\t} else {\n\t\tasyncCallbacks.add(asyncCallbackConfig);\n\t}\n\n\tif (!isRegistered) {\n\t\tisRegistered = true;\n\n\t\t// Exit cases that support asynchronous handling\n\t\tprocess.once('beforeExit', exit.bind(undefined, true, false, -128));\n\t\tprocess.once('SIGINT', exit.bind(undefined, true, false, 2));\n\t\tprocess.once('SIGTERM', exit.bind(undefined, true, false, 15));\n\n\t\t// Explicit exit events. Calling will force an immediate exit and run all\n\t\t// synchronous hooks. Explicit exits must not extend the node process\n\t\t// artificially. Will log errors if asynchronous calls exist.\n\t\tprocess.once('exit', exit.bind(undefined, false, true, 0));\n\n\t\t// PM2 Cluster shutdown message. Caught to support async handlers with pm2,\n\t\t// needed because explicitly calling process.exit() doesn't trigger the\n\t\t// beforeExit event, and the exit event cannot support async handlers,\n\t\t// since the event loop is never called after it.\n\t\tprocess.on('message', message => {\n\t\t\tif (message === 'shutdown') {\n\t\t\t\texit(true, true, -128);\n\t\t\t}\n\t\t});\n\t}\n\n\treturn () => {\n\t\tif (isSynchronous) {\n\t\t\tcallbacks.delete(onExit);\n\t\t} else {\n\t\t\tasyncCallbacks.delete(asyncCallbackConfig);\n\t\t}\n\t};\n}\n\nexport default function exitHook(onExit) {\n\tif (typeof onExit !== 'function') {\n\t\tthrow new TypeError('onExit must be a function');\n\t}\n\n\treturn addHook({\n\t\tonExit,\n\t\tisSynchronous: true,\n\t});\n}\n\nexport function asyncExitHook(onExit, options = {}) {\n\tif (typeof onExit !== 'function') {\n\t\tthrow new TypeError('onExit must be a function');\n\t}\n\n\tif (!(typeof options.wait === 'number' && options.wait > 0)) {\n\t\tthrow new TypeError('wait must be set to a positive numeric value');\n\t}\n\n\treturn addHook({\n\t\tonExit,\n\t\twait: options.wait,\n\t\tisSynchronous: false,\n\t});\n}\n\nexport function gracefulExit(signal = 0) {\n\texit(true, false, -128 + signal);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}